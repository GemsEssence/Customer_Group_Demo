module CustomerGroups
  module Create
    class << self
      def call(customer_group, customer_ids, error_tracker = ::ErrorTracker.new)

        ActiveRecord::Base.transaction do
          customer_group = save_customer_group(customer_group, error_tracker)

          assign_group_to_customers(customer_ids, customer_group.id, error_tracker)
          # assign_group_to_owner(customer_group.id, error_tracker)

          raise Exceptions::InvalidRecordException if error_tracker.has_error?

          { success: true, errors: [], result: customer_group }
        end
      rescue Exceptions::InvalidRecordException
        { success: false, errors: error_tracker.error_list, result: nil }
      end

      private

      def save_customer_group(customer_group, error_tracker)
        return customer_group if customer_group.save

        error_tracker.add_errors(customer_group.errors.full_messages)
        raise Exceptions::InvalidRecordException
      end

      def assign_group_to_customers(customer_ids, customer_group_id, error_tracker)
        customers = Customers.where(id: customer_ids)
        customer_group_ids = Customers.pluck(:customer_group_id)

        update_customers(customers, customer_group_id, error_tracker)
        reset_customer_position(customer_group_ids, customer_group_id, error_tracker)
      end

      def update_customers(customers, customer_group_id, error_tracker)
        is_saved_all_customers = true
        customers.each do |customer|
          customer.update(customer_group_id: customer_group_id)
          if is_saved_all_customers && customer.errors.any?
            is_saved_all_customers = false
            break;
          end
        end

        return if is_saved_all_customers

        error_tracker.add_errors("Unable to assign customer to customer group.")
      end

      def reset_customer_position(customer_group_ids, customer_group_id, error_tracker)
        reset_customer_position_for_existing_groups(customer_group_ids, error_tracker)
        reset_customer_position_for_new_group(customer_group_id, error_tracker)
      end

      def reset_customer_position_for_existing_groups(customer_group_ids, error_tracker)
        CustomerGroups::ResetCustomerPosition.call(customer_group_ids, error_tracker)
      end

      def reset_customer_position_for_new_group(customer_group_id, error_tracker)
        CustomerGroups::ResetCustomerPosition.call([customer_group_id], error_tracker)
      end
    end
  end
end

The above code is an operations code please write the rspecs of this operations make sure to cover all the negatives and the positive cases

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Response - by chatGpt  

require 'rails_helper'

RSpec.describe CustomerGroups::Create do
  describe '.call' do
    let(:error_tracker) { instance_double('ErrorTracker', add_errors: nil, error_list: [], has_error?: false) }
    let(:customer_group) { double('CustomerGroup', id: 1, save: true, errors: double(full_messages: [])) }
    let(:customer_ids) { [1, 2, 3] }
    let(:customers) { [double('Customer', id: 1, errors: []), double('Customer', id: 2, errors: [])] }

    before do
      allow(::ErrorTracker).to receive(:new).and_return(error_tracker)
      allow(customer_group).to receive(:save).and_return(true)
      allow(Customers).to receive(:where).and_return(customers)
      allow(Customers).to receive(:pluck).and_return([nil, nil, nil])
      allow(CustomerGroups::ResetCustomerPosition).to receive(:call).and_return(true)
    end

    context 'when customer group creation and assignment succeeds' do
      it 'returns a success result' do
        result = described_class.call(customer_group, customer_ids, error_tracker)

        expect(result[:success]).to eq(true)
        expect(result[:errors]).to eq([])
        expect(result[:result]).to eq(customer_group)
      end

      it 'calls reset customer positions' do
        described_class.call(customer_group, customer_ids, error_tracker)

        expect(CustomerGroups::ResetCustomerPosition).to have_received(:call).twice
      end
    end

    context 'when customer group fails to save' do
      before do
        allow(customer_group).to receive(:save).and_return(false)
        allow(customer_group.errors).to receive(:full_messages).and_return(['Name can\'t be blank'])
        allow(error_tracker).to receive(:has_error?).and_return(true)
      end

      it 'adds errors to the error tracker and returns failure' do
        result = described_class.call(customer_group, customer_ids, error_tracker)

        expect(result[:success]).to eq(false)
        expect(result[:errors]).to include("Name can't be blank")
        expect(result[:result]).to be_nil
      end
    end

    context 'when updating customers fails' do
      before do
        allow(customers.first).to receive(:update).and_wrap_original do |method, *args|
          customers.first.errors << 'Update failed'
          method.call(*args)
        end
        allow(error_tracker).to receive(:has_error?).and_return(true)
      end

      it 'adds errors to the error tracker and returns failure' do
        result = described_class.call(customer_group, customer_ids, error_tracker)

        expect(result[:success]).to eq(false)
        expect(result[:errors]).to include('Unable to assign customer to customer group.')
        expect(result[:result]).to be_nil
      end
    end

    context 'when reset customer position raises an exception' do
      before do
        allow(CustomerGroups::ResetCustomerPosition).to receive(:call).and_raise(StandardError, 'Reset failed')
        allow(error_tracker).to receive(:has_error?).and_return(true)
      end

      it 'captures the error and returns failure' do
        expect {
          described_class.call(customer_group, customer_ids, error_tracker)
        }.to raise_error(StandardError, 'Reset failed')
      end
    end

    context 'when there are no customers to assign' do
      before do
        allow(Customers).to receive(:where).and_return([])
      end

      it 'still succeeds without errors' do
        result = described_class.call(customer_group, [], error_tracker)

        expect(result[:success]).to eq(true)
        expect(result[:errors]).to eq([])
        expect(result[:result]).to eq(customer_group)
      end
    end
  end
end

NOTE - There are some changes we did after taking the code from the AI
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ END ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++