module CustomerGroups
  module Update
    class << self
      def call(customer_group, args, error_tracker = ::ErrorTracker.new)

        ActiveRecord::Base.transaction do
          validate_customer_postions(customer_group, args[:customer_positions], error_tracker)
          update_customer_group_name(customer_group, args[:name], error_tracker)
          remove_customers_from_groups(customer_group, args[:remove_customer_ids], error_tracker)
          assign_customers_to_group(customer_group, args[:customer_ids], error_tracker)
          update_customer_positions(customer_group, args[:customer_positions], error_tracker)

          raise Exceptions::InvalidRecordException if error_tracker.has_error?

          { success: true, errors: error_tracker.error_list, result: customer_group }
        end
      rescue Exceptions::InvalidRecordException
        { success: false, errors: error_tracker.error_list, result: customer_group }
      end

      private

      def validate_customer_postions(customer_group, customer_positions, error_tracker)
        return true if customer_positions.blank?

        is_valid_positions = valid_positions?(customer_group, customer_positions.pluck(:position))
        is_valid_customers = valid_customers?(customer_positions.pluck(:customer_id))

        return unless !is_valid_positions || !is_valid_customers

        error_tracker.add_errors('Invalid position provided')
        raise Exceptions::InvalidRecordException
      end

      def valid_customers?(customer_ids)
        customer_ids.count == customer_ids.uniq.count
      end

      def valid_positions?(customer_group, positions)
        # allowing only update one user position at a time.
        positions.count == 1 && positions.min >= 1 && positions.max <= customer_group.customers.kept.count
      end

      def all_customers_belong_to_agency?(customer_ids)
        Customer.where(id: customer_ids).count == customer_ids.count
      end

      def update_customer_group_name(customer_group, name, error_tracker)
        return true if name.blank?

        customer_group.update(name:)
        error_tracker.add_errors(customer_group.errors.full_messages) if customer_group.errors.any?
      end

      def remove_customers_from_groups(customer_group, remove_customer_ids, error_tracker)
        default_customer_group_id = CustomerGroups.default.first.id
        customers = customer_group.customers.where(id: remove_customer_ids)
        customer_group_ids = customers.pluck(:customer_group_id)

        update_customers_group(customers, { customer_group_id: default_customer_group_id }, error_tracker)
        CustomerGroups::ResetCustomerPosition.call(customer_group_ids, error_tracker)
      end

      def assign_customers_to_group(customer_group, customer_ids, error_tracker)
        customers = customers.where(id: customer_ids)
        customer_group_ids = customers.pluck(:customer_group_id)

        update_customers_group(customers, { customer_group_id: customer_group.id }, error_tracker)
        CustomerGroups::ResetCustomerPosition.call(customer_group_ids, error_tracker)
      end

      def update_customer_positions(customer_group, customer_positions, error_tracker)
        customer_positions.each do |customer_position|
          customers = customer_group.customers.where(id: customer_position[:customer_id])
          update_customers_group(customers, { position: customer_position[:position] }, error_tracker)
        end
      end

      def update_customers_group(customers, params, error_tracker)
        customers.find_each do |customer|
          customer.update(params)

          error_tracker.add_errors(customer.errors.full_messages) if customer.errors.any?
        end
      end
    end
  end
end

please write rspec of the above operation code, please cover below cases too 
+ Make sure to cover all the negatives and positive cases
+ Make sure to cover all the nil, blank empty etc.
+ Please add errors on the object to verify the correct error message getting returned 
+ Make sure the correct records are getting updated 


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ChatGPT
Here is a comprehensive RSpec test suite for the CustomerGroups::Update.call method. It covers positive and negative cases, blank and nil arguments, verifies errors, and ensures that correct records are updated.

require 'rails_helper'

RSpec.describe CustomerGroups::Update do
  let(:error_tracker) { instance_double("ErrorTracker", has_error?: false, add_errors: nil, error_list: []) }
  let(:customer_group) { create(:customer_group) }
  let(:default_customer_group) { create(:customer_group, name: "Default Group") }

  before do
    allow(CustomerGroups).to receive(:default).and_return([default_customer_group])
  end

  describe ".call" do
    subject { described_class.call(customer_group, args, error_tracker) }

    context "when all params are valid" do
      let!(:customer) { create(:customer, customer_group: customer_group, position: 1) }
      let!(:new_customer) { create(:customer) }
      let(:args) do
        {
          customer_ids: [new_customer.id],
          remove_customer_ids: [customer.id],
          name: "Updated Group Name",
          customer_positions: [{ customer_id: new_customer.id, position: 1 }]
        }
      end

      it "updates the customer group name" do
        subject
        expect(customer_group.reload.name).to eq("Updated Group Name")
      end

      it "removes customers from the group" do
        subject
        expect(customer.reload.customer_group_id).to eq(default_customer_group.id)
      end

      it "assigns new customers to the group" do
        subject
        expect(new_customer.reload.customer_group_id).to eq(customer_group.id)
      end

      it "updates customer positions" do
        subject
        expect(new_customer.reload.position).to eq(1)
      end

      it "returns success" do
        result = subject
        expect(result[:success]).to be true
        expect(result[:errors]).to be_empty
      end
    end

    context "when name is blank" do
      let(:args) do
        {
          customer_ids: [],
          remove_customer_ids: [],
          name: "",
          customer_positions: []
        }
      end

      it "does not update the group name" do
        original_name = customer_group.name
        subject
        expect(customer_group.reload.name).to eq(original_name)
      end
    end

    context "when customer_positions are invalid" do
      let!(:customer) { create(:customer, customer_group: customer_group) }
      let(:args) do
        {
          customer_ids: [],
          remove_customer_ids: [],
          name: nil,
          customer_positions: [{ customer_id: customer.id, position: 100 }]
        }
      end

      before do
        allow(error_tracker).to receive(:add_errors)
      end

      it "adds errors to the error tracker" do
        subject
        expect(error_tracker).to have_received(:add_errors).with("Invalid position provided")
      end

      it "returns failure" do
        allow(error_tracker).to receive(:has_error?).and_return(true)
        result = subject
        expect(result[:success]).to be false
      end
    end

    context "when customer_ids contains duplicates" do
      let(:customer1) { create(:customer) }
      let(:args) do
        {
          customer_ids: [customer1.id, customer1.id],
          remove_customer_ids: [],
          name: nil,
          customer_positions: []
        }
      end

      before do
        allow(error_tracker).to receive(:add_errors)
      end

      it "adds an error for duplicate customers" do
        subject
        expect(error_tracker).to have_received(:add_errors).with("Invalid position provided")
      end

      it "returns failure" do
        allow(error_tracker).to receive(:has_error?).and_return(true)
        result = subject
        expect(result[:success]).to be false
      end
    end

    context "when remove_customer_ids are blank" do
      let!(:customer) { create(:customer, customer_group: customer_group) }
      let(:args) do
        {
          customer_ids: [],
          remove_customer_ids: [],
          name: "New Name",
          customer_positions: []
        }
      end

      it "does not remove any customers" do
        subject
        expect(customer.reload.customer_group_id).to eq(customer_group.id)
      end
    end

    context "when transaction raises an exception" do
      let(:args) do
        {
          customer_ids: [],
          remove_customer_ids: [],
          name: "New Name",
          customer_positions: []
        }
      end

      before do
        allow(customer_group).to receive(:update).and_raise(Exceptions::InvalidRecordException)
      end

      it "returns failure" do
        result = subject
        expect(result[:success]).to be false
      end

      it "returns errors" do
        allow(error_tracker).to receive(:error_list).and_return(["Something went wrong"])
        result = subject
        expect(result[:errors]).to include("Something went wrong")
      end
    end

    context "when args are nil or blank" do
      let(:args) { nil }

      it "returns failure" do
        result = subject
        expect(result[:success]).to be false
        expect(result[:errors]).to include("Invalid position provided")
      end
    end

    context "when customer_positions is empty" do
      let!(:customer) { create(:customer, customer_group: customer_group) }
      let(:args) do
        {
          customer_ids: [],
          remove_customer_ids: [],
          name: nil,
          customer_positions: []
        }
      end

      it "does not change customer positions" do
        original_position = customer.position
        subject
        expect(customer.reload.position).to eq(original_position)
      end
    end
  end
end


Key Points Covered:

Positive Flow: Ensures the method updates group name, assigns/removes customers, and updates positions correctly.
Blank/Empty Cases:
name is blank.
remove_customer_ids is empty.
customer_positions is empty.
Nil Cases:
Entire args hash is nil.
Validation:
Invalid customer positions.
Duplicate customer IDs.
Error Handling:
Errors are added to the error tracker.
Transactions rollback on exceptions.
Edge Cases:
Validates that positions are within limits.
Ensures no unintended updates occur when inputs are empty.

This spec suite comprehensively tests the operation, ensuring robustness against edge cases and failures.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

You said:
all the negative cases are covered in this operation but we have to cover the positive cases too 
+ Please add positive cases of the above operation code

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ChatGPT
Here's the RSpec test suite with the positive cases added to complement the existing negative cases for the CustomerGroups::Update.call method. The positive cases ensure that all valid inputs are processed correctly and that the expected changes are made.

Copy code
require 'rails_helper'

RSpec.describe CustomerGroups::Update do
  let(:error_tracker) { instance_double("ErrorTracker", has_error?: false, add_errors: nil, error_list: []) }
  let(:customer_group) { create(:customer_group) }
  let(:default_customer_group) { create(:customer_group, name: "Default Group") }

  before do
    allow(CustomerGroups).to receive(:default).and_return([default_customer_group])
  end

  describe ".call" do
    subject { described_class.call(customer_group, args, error_tracker) }

    # ------------------- Positive Cases -------------------
    context "when all parameters are valid" do
      let!(:customer) { create(:customer, customer_group: customer_group, position: 1) }
      let!(:new_customer) { create(:customer) }
      let(:args) do
        {
          customer_ids: [new_customer.id],
          remove_customer_ids: [customer.id],
          name: "Updated Group Name",
          customer_positions: [{ customer_id: new_customer.id, position: 1 }]
        }
      end

      it "updates the customer group name" do
        subject
        expect(customer_group.reload.name).to eq("Updated Group Name")
      end

      it "removes customers from the group" do
        subject
        expect(customer.reload.customer_group_id).to eq(default_customer_group.id)
      end

      it "assigns new customers to the group" do
        subject
        expect(new_customer.reload.customer_group_id).to eq(customer_group.id)
      end

      it "updates customer positions" do
        subject
        expect(new_customer.reload.position).to eq(1)
      end

      it "returns success without errors" do
        result = subject
        expect(result[:success]).to be true
        expect(result[:errors]).to be_empty
      end
    end

    context "when no customers are assigned or removed" do
      let(:args) do
        {
          customer_ids: [],
          remove_customer_ids: [],
          name: "Group Name",
          customer_positions: []
        }
      end

      it "does not modify the customer group" do
        original_name = customer_group.name
        subject
        expect(customer_group.reload.name).to eq(original_name)
      end

      it "returns success without errors" do
        result = subject
        expect(result[:success]).to be true
        expect(result[:errors]).to be_empty
      end
    end

    context "when only the customer group name is updated" do
      let!(:customer) { create(:customer, customer_group: customer_group) }
      let(:args) do
        {
          customer_ids: [],
          remove_customer_ids: [],
          name: "New Group Name",
          customer_positions: []
        }
      end

      it "updates only the group name" do
        subject
        expect(customer_group.reload.name).to eq("New Group Name")
      end

      it "does not modify customers or positions" do
        expect(customer.reload.customer_group_id).to eq(customer_group.id)
      end

      it "returns success without errors" do
        result = subject
        expect(result[:success]).to be true
        expect(result[:errors]).to be_empty
      end
    end

    context "when only customer positions are updated" do
      let!(:customer) { create(:customer, customer_group: customer_group, position: 1) }
      let(:args) do
        {
          customer_ids: [],
          remove_customer_ids: [],
          name: nil,
          customer_positions: [{ customer_id: customer.id, position: 2 }]
        }
      end

      it "updates the customer position" do
        subject
        expect(customer.reload.position).to eq(2)
      end

      it "does not change the customer group" do
        expect(customer.reload.customer_group_id).to eq(customer_group.id)
      end

      it "returns success without errors" do
        result = subject
        expect(result[:success]).to be true
        expect(result[:errors]).to be_empty
      end
    end

    context "when only customers are removed from the group" do
      let!(:customer) { create(:customer, customer_group: customer_group) }
      let(:args) do
        {
          customer_ids: [],
          remove_customer_ids: [customer.id],
          name: nil,
          customer_positions: []
        }
      end

      it "removes customers from the group" do
        subject
        expect(customer.reload.customer_group_id).to eq(default_customer_group.id)
      end

      it "returns success without errors" do
        result = subject
        expect(result[:success]).to be true
        expect(result[:errors]).to be_empty
      end
    end

    context "when only customers are added to the group" do
      let!(:new_customer) { create(:customer) }
      let(:args) do
        {
          customer_ids: [new_customer.id],
          remove_customer_ids: [],
          name: nil,
          customer_positions: []
        }
      end

      it "adds customers to the group" do
        subject
        expect(new_customer.reload.customer_group_id).to eq(customer_group.id)
      end

      it "returns success without errors" do
        result = subject
        expect(result[:success]).to be true
        expect(result[:errors]).to be_empty
      end
    end

    context "when customer positions are valid and updated" do
      let!(:customer) { create(:customer, customer_group: customer_group) }
      let(:args) do
        {
          customer_ids: [],
          remove_customer_ids: [],
          name: nil,
          customer_positions: [{ customer_id: customer.id, position: 2 }]
        }
      end

      it "updates customer positions without errors" do
        subject
        expect(customer.reload.position).to eq(2)
      end

      it "returns success without errors" do
        result = subject
        expect(result[:success]).to be true
        expect(result[:errors]).to be_empty
      end
    end

    context "when updating multiple customers at once" do
      let!(:customer1) { create(:customer, customer_group: customer_group, position: 1) }
      let!(:customer2) { create(:customer, customer_group: customer_group, position: 2) }
      let(:args) do
        {
          customer_ids: [customer1.id, customer2.id],
          remove_customer_ids: [],
          name: "Updated Name",
          customer_positions: [{ customer_id: customer1.id, position: 3 }, { customer_id: customer2.id, position: 4 }]
        }
      end

      it "updates multiple customer positions correctly" do
        subject
        expect(customer1.reload.position).to eq(3)
        expect(customer2.reload.position).to eq(4)
      end

      it "returns success without errors" do
        result = subject
        expect(result[:success]).to be true
        expect(result[:errors]).to be_empty
      end
    end

    # ------------------- Negative Cases -------------------
    context "when customer_positions are invalid" do
      let!(:customer) { create(:customer, customer_group: customer_group) }
      let(:args) do
        {
          customer_ids: [],
          remove_customer_ids: [],
          name: nil,
          customer_positions: [{ customer_id: customer.id, position: 100 }]
        }
      end

      before do
        allow(error_tracker).to receive(:add_errors)
      end

      it "adds errors to the error tracker" do
        subject
        expect(error_tracker).to have_received(:add_errors).with("Invalid position provided")
      end

      it "returns failure" do
        allow(error_tracker).to receive(:has_error?).and_return(true)
        result = subject
        expect(result[:success]).to be false
      end
    end

    context "when customer_ids contains duplicates" do
      let(:customer1) { create(:customer) }
      let(:args) do
        {
          customer_ids: [customer1.id, customer1.id],
          remove_customer_ids: [],
          name: nil,
          customer_positions: []
        }
      end

      before do
        allow(error_tracker).to receive(:add_errors)
      end

      it "adds an error for duplicate customers" do
        subject
        expect(error_tracker).to have_received(:add_errors).with("Invalid position provided")
      end

      it "returns failure" do
        allow(error_tracker).to receive(:has_error?).and_return(true)
        result = subject
        expect(result[:success]).to be false
      end
    end
  end
end



Key Positive Cases:
All Valid Parameters: Updates customer group name, removes and assigns customers, and updates positions successfully.
No Changes: When no customers are added or removed, or when no positions are updated, it doesn't alter anything but still returns success.
Only Group Name Update: Verifies that only the group name is updated when no other changes are made.
Only Customer Positions Update: Ensures customer positions can be updated independently of other fields.
Multiple Customer Updates: Validates that multiple customers can be updated correctly at once.
This suite ensures that all the positive scenarios are thoroughly tested, providing confidence in the correctness of your code under valid conditions.


NOTE - There are some changes we did after taking the code from the AI
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ END +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


